package sqld

import (
	"context"
	"time"
)

// This file shows how to use the sqlc-dynamic library with existing sqlc-generated code

// Example: Assuming you have sqlc-generated code like this:
/*
// Generated by sqlc
type User struct {
    ID        int64     `db:"id" json:"id"`
    Name      string    `db:"name" json:"name"`
    Email     string    `db:"email" json:"email"`
    Status    string    `db:"status" json:"status"`
    Country   *string   `db:"country" json:"country"`
    CreatedAt time.Time `db:"created_at" json:"created_at"`
}

type Queries struct {
    db DBTX
}

func (q *Queries) GetUser(ctx context.Context, id int64) (User, error) {
    // sqlc-generated implementation
}

func (q *Queries) ListUsers(ctx context.Context) ([]User, error) {
    // sqlc-generated implementation
}
*/

// UserSearchFilters represents search criteria for users
type UserSearchFilters struct {
	Name         string
	Email        string
	Status       string
	Countries    []string
	CreatedAfter *time.Time
	SearchText   string
	Active       *bool
}

// UserService demonstrates how to use the dynamic library
type UserService struct {
	enhanced *EnhancedQueries[*Queries] // Replace with your actual Queries type
}

// NewUserService creates a new user service with dynamic query capabilities
func NewUserService(queries *Queries, db DBTX, dialect Dialect) *UserService {
	return &UserService{
		enhanced: NewEnhanced(queries, db, dialect),
	}
}

// SearchUsers demonstrates dynamic user search
func (s *UserService) SearchUsers(ctx context.Context, filters UserSearchFilters) ([]User, error) {
	baseQuery := `
		SELECT id, name, email, status, country, created_at 
		FROM users`
	
	// Build dynamic conditions
	where := NewWhereBuilder(Postgres)
	
	// Add search conditions
	if filters.SearchText != "" {
		searchColumns := []string{"name", "email"}
		searchWhere := s.enhanced.SearchQuery(baseQuery, searchColumns, filters.SearchText, nil)
		if searchWhere.HasConditions() {
			searchSQL, searchParams := searchWhere.Build()
			where.Raw(searchSQL, searchParams...)
		}
	}
	
	// Add specific filters
	ConditionalWhere(where, "name", filters.Name)
	ConditionalWhere(where, "email", filters.Email)
	ConditionalWhere(where, "status", filters.Status)
	
	// Add array filter
	if len(filters.Countries) > 0 {
		countryValues := make([]interface{}, len(filters.Countries))
		for i, country := range filters.Countries {
			countryValues[i] = country
		}
		where.In("country", countryValues)
	}
	
	// Add date filter
	if filters.CreatedAfter != nil {
		where.GreaterThan("created_at", *filters.CreatedAfter)
	}
	
	// Add boolean filter
	if filters.Active != nil {
		if *filters.Active {
			where.Equal("status", "active")
		} else {
			where.NotEqual("status", "active")
		}
	}
	
	// Execute the query
	var users []User
	err := s.enhanced.DynamicQuery(ctx, baseQuery, where, func(rows Rows) error {
		scanFunc := func(rows Rows) (User, error) {
			var u User
			err := rows.Scan(&u.ID, &u.Name, &u.Email, &u.Status, &u.Country, &u.CreatedAt)
			return u, err
		}
		
		result, err := ScanToSlice(rows, scanFunc)
		if err != nil {
			return err
		}
		users = result
		return nil
	})
	
	return users, err
}

// SearchUsersWithPagination demonstrates pagination with dynamic conditions
func (s *UserService) SearchUsersWithPagination(
	ctx context.Context,
	filters UserSearchFilters,
	page, pageSize int,
	orderBy string,
) ([]User, int, error) {
	baseQuery := `SELECT id, name, email, status, country, created_at FROM users`
	
	// Build conditions (reuse logic from SearchUsers)
	where := s.buildUserFilters(filters)
	
	// Get total count
	countQuery := `SELECT COUNT(*) FROM users`
	var totalCount int
	
	countRow := s.enhanced.DynamicQueryRow(ctx, countQuery, where)
	if err := countRow.Scan(&totalCount); err != nil {
		return nil, 0, err
	}
	
	// Get paginated results
	offset := (page - 1) * pageSize
	query, params := s.enhanced.PaginationQuery(baseQuery, where, pageSize, offset, orderBy)
	
	rows, err := s.enhanced.DB().Query(ctx, query, params...)
	if err != nil {
		return nil, 0, err
	}
	defer rows.Close()
	
	users, err := ScanToSlice(rows, func(rows Rows) (User, error) {
		var u User
		err := rows.Scan(&u.ID, &u.Name, &u.Email, &u.Status, &u.Country, &u.CreatedAt)
		return u, err
	})
	
	return users, totalCount, err
}

// GetUserStats demonstrates aggregation with dynamic conditions
func (s *UserService) GetUserStats(ctx context.Context, filters UserSearchFilters) (map[string]int, error) {
	baseQuery := `
		SELECT status, COUNT(*) as count 
		FROM users`
	
	where := s.buildUserFilters(filters)
	
	qb := NewQueryBuilder(baseQuery, Postgres)
	qb.Where(where)
	query, params := qb.Build()
	query += " GROUP BY status ORDER BY status"
	
	rows, err := s.enhanced.DB().Query(ctx, query, params...)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	
	return ScanToMap(rows, 
		func(rows Rows) (string, error) {
			var status string
			var count int
			err := rows.Scan(&status, &count)
			return status, err
		},
		func(rows Rows) (int, error) {
			var status string
			var count int
			err := rows.Scan(&status, &count)
			return count, err
		},
	)
}

// buildUserFilters is a helper method to build common user filters
func (s *UserService) buildUserFilters(filters UserSearchFilters) *WhereBuilder {
	where := NewWhereBuilder(Postgres)
	
	// Text search
	if filters.SearchText != "" {
		where.Or(func(or ConditionBuilder) {
			or.ILike("name", SearchPattern(filters.SearchText, "contains"))
			or.ILike("email", SearchPattern(filters.SearchText, "contains"))
		})
	}
	
	// Exact matches
	ConditionalWhere(where, "name", filters.Name)
	ConditionalWhere(where, "email", filters.Email)
	ConditionalWhere(where, "status", filters.Status)
	
	// Array filter
	if len(filters.Countries) > 0 {
		countryValues := make([]interface{}, len(filters.Countries))
		for i, country := range filters.Countries {
			countryValues[i] = country
		}
		where.In("country", countryValues)
	}
	
	// Date filter
	if filters.CreatedAfter != nil {
		where.GreaterThan("created_at", *filters.CreatedAfter)
	}
	
	return where
}

// ComplexQueryExample demonstrates a complex query with multiple JOINs and dynamic conditions
func (s *UserService) GetUsersWithOrderStats(
	ctx context.Context,
	userFilters UserSearchFilters,
	minOrderCount int,
	minOrderTotal float64,
) ([]UserWithStats, error) {
	
	baseQuery := `
		SELECT 
			u.id, u.name, u.email, u.status, u.country, u.created_at,
			COUNT(o.id) as order_count,
			COALESCE(SUM(o.total), 0) as total_spent
		FROM users u
		LEFT JOIN orders o ON o.user_id = u.id AND o.status = 'completed'`
	
	// Build user filters for WHERE clause
	where := s.buildUserFilters(userFilters)
	
	// Build HAVING conditions for aggregates
	having := NewWhereBuilder(Postgres)
	if minOrderCount > 0 {
		having.GreaterThan("COUNT(o.id)", minOrderCount)
	}
	if minOrderTotal > 0 {
		having.GreaterThan("COALESCE(SUM(o.total), 0)", minOrderTotal)
	}
	
	// Build the complete query
	qb := NewQueryBuilder(baseQuery, Postgres)
	qb.Where(where)
	query, params := qb.Build()
	
	// Add GROUP BY
	query += " GROUP BY u.id, u.name, u.email, u.status, u.country, u.created_at"
	
	// Add HAVING conditions
	if having.HasConditions() {
		havingSQL, havingParams := having.Build()
		
		// Adjust parameter indices for PostgreSQL
		adjuster := NewParameterAdjuster(Postgres)
		havingSQL = adjuster.AdjustSQL(havingSQL, len(params))
		
		query += " HAVING " + havingSQL
		params = append(params, havingParams...)
	}
	
	query += " ORDER BY total_spent DESC"
	
	rows, err := s.enhanced.DB().Query(ctx, query, params...)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	
	return ScanToSlice(rows, func(rows Rows) (UserWithStats, error) {
		var u UserWithStats
		err := rows.Scan(
			&u.ID, &u.Name, &u.Email, &u.Status, &u.Country, &u.CreatedAt,
			&u.OrderCount, &u.TotalSpent,
		)
		return u, err
	})
}

// Working with existing sqlc queries
func (s *UserService) EnhanceExistingQuery(ctx context.Context, userId int64, filters UserSearchFilters) (User, error) {
	// Start with base sqlc query
	baseQuery := `SELECT id, name, email, status, country, created_at FROM users WHERE id = $1`
	
	// Add dynamic conditions
	where := s.buildUserFilters(filters)
	
	// Inject conditions into existing query
	finalQuery, params := InjectWhereCondition(baseQuery, where, Postgres)
	
	// Prepend the original parameter
	allParams := append([]interface{}{userId}, params...)
	
	row := s.enhanced.DB().QueryRow(ctx, finalQuery, allParams...)
	
	var user User
	err := row.Scan(&user.ID, &user.Name, &user.Email, &user.Status, &user.Country, &user.CreatedAt)
	return user, err
}

// Supporting types for the examples
type UserWithStats struct {
	User
	OrderCount int     `db:"order_count" json:"order_count"`
	TotalSpent float64 `db:"total_spent" json:"total_spent"`
}

// Mock types to represent sqlc-generated code
type User struct {
	ID        int64     `db:"id" json:"id"`
	Name      string    `db:"name" json:"name"`
	Email     string    `db:"email" json:"email"`
	Status    string    `db:"status" json:"status"`
	Country   *string   `db:"country" json:"country"`
	CreatedAt time.Time `db:"created_at" json:"created_at"`
}

type Queries struct {
	db DBTX
}

func (q *Queries) GetUser(ctx context.Context, id int64) (User, error) {
	// This would be your actual sqlc-generated method
	return User{}, nil
}

func (q *Queries) ListUsers(ctx context.Context) ([]User, error) {
	// This would be your actual sqlc-generated method
	return nil, nil
}